# HTTP

## IP (Internet Protocol)

- 인터넷 프로토콜의 역할
  - 지정한 IP 주소(IP Address)에 데이터 전달
  - 패킷(packet)이라는 통신 단위로 데이터 전달
- 패킷(packet)
  - 컴퓨터 간에 데이터를 주고받을 때 **네트워크를 통해 전송되는 데이터의 작은 조각**

- IP 프로토콜의 한계
  - 비 연결성
    - 패킷을 받을 대상이 없거나 서비스가 불능 상태여도 패킷을 전송한다.
  - 비 신뢰성
    - 데이터를 전송하는 과정에서 패킷이 사라지게 된다면?
    - 패킷이 서버나 클라이언트에게 지정한 순서대로 도착하지 않는다면?
  - 프로그램 구분
    - 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상이라면 어떻게 구분해야 될까?

## TCP와 UDP

<p align="center">
  <img src ="https://user-images.githubusercontent.com/52318666/177295349-7e034940-3214-4658-9318-ca3173643f3f.png" >
</p>

### TCP (Transmission Control Protocol)

- TCP(전송 제어 프로토콜)의 특징
  - 연결 지향 - TCP 3way handshake (가상 연결)
  - 데이터 전달을 보증한다.
  - 데이터가 전달되는 순서를 보증한다.
  - 신뢰할 수 있는 프로토콜로 현재는 대부분 TCP를 사용한다.
- TCP 3way handshake
  1. SYN : 클라이언트가 서버에 접속 요청
  2. SYN+ACK : 클라이언트의 요청을 서버에서 수락하고, 서버가 클라이언트에게 접속 요청
  3. ACK : 서버의 요청을 클라이언트에서 수락, 서버에서 ACK를 보낼 때는 데이터도 함께 전송 가능

### UDP (User Datagram Protocol)

- UDP (사용자 데이터그램 프로토콜)의 특징

  - 기능이 거의 없다.

  - 연결 지향 - TCP 3way handshake ❌

  - 데이터 전달을 보증하지 않는다.

  - 데이터가 전달되는 순서를 보증하지 않는다.

  - 단순하고 전송 속도가 빠르다.

  - IP와 거의 같고, PORT와 체크섬 정도만 추가되었다.

  - 애플리케이션에서 추가 작업이 필요하다.

## PORT

- 컴퓨터가 데이터 통신을 할 때 통신하고자 하는 네트워크 서비스나 특정 프로세스를 식별하는 논리 단위이다.
- 포트 번호는 0 ~ 65535번을 사용할 수 있다.
- 0 ~ 1023번은 잘 알려진 포트(well-known ports)로 특정 애플리케이션이 사용할 수 있도록 예약된 번호로 사용하지 않는 것이 좋다.
  - FPT - 20, 21
  - TELNET - 23
  - HTTP - 80
  - HTTPS - 443

## DNS (Domain Name System) 

- 네트워크에서 호스트 이름을 IP 주소로 변환하는 데 사용하는 시스템(서비스)이다.
- 특정 컴퓨터(또는 네트워크로 연결된 임의의 장치)의 주소를 찾기 위해, 사람이 이해하기 쉬운 도메인 이름을 숫자로 된 식별 번호(IP 주소)로 변환해준다.
- DNS가 동작하는 컴퓨터(서버)를 DNS 서버라고 한다.

## URI

- URI(Uniform Resource Identifier, 통합 자원 식별자)
  - Uniform : 리소스를 식별하는 통일된 방식
  - Resource : 자원, URI로 식별할 수 있는 모든 것(제한 X)
    - ex) 웹 서버 파일 시스템의 정적 파일들 : 텍스트 파일, HTML 파일, word 파일, JPEG 이미지 파일 등
    - ex) 요청에 따라 동적으로 콘텐츠를 생산하는 프로그램
  - Identifier : 다른 항목과 구분하는데 필요한 정보
  - URI는 URL과 URN 두 가지 종류가 있다.
- URL(Uniform Resource Locator, 통합 자원 지시자)
  - Locator : 리소스가 있는 위치를 지정
  - 특정 서버의 한 리소스에 대한 구체적인 위치를 서술하여 리소스가 정확히 어디에 있고 어떻게 접근할 수 있는지 알려준다.
- URN(Uniform Resource Name, 통합 리소스 이름)
  - Name : 리소스에 이름을 부여

```tex
> URL 전체 문법
- scheme://[userinfo@]host[:port][/path][?query][#fragment]
- 프로토콜, 호스트명, 포트 번호, 패스, 쿼리 파라미터로 구성
- https://www.google.com:443/search?q=hello&hl=ko
```

- scheme
  - 주로 프로토콜을 사용
  - 프로토콜 : 어떤 방식으로 자원에 접근할 것이나 하는 약속 규칙으로 http, https, ftp 등이 있다.
  - http는 80 포트, https는 443 포트 번호를 주로 사용하고, 포트 번호는 생략이 가능하다.

- userinfo
  - URL에 사용자 정보를 포함해서 인증한다.
  - 거의 사용하지 않는다.
- host
  - 호스트 명, 도메인 명 또는 IP 주소를 직접 사용가능하다.
- port
  - 접속 포트 번호로 일반적으로 생략한다.
- path
  - 리소스가 위치한 경로를 나타낸다.
- query
  - key=value 형태로 '?'로 시작하고, '&'로 추가 가능하다.
  - ex) ?keyA=valueA&keyB=valueB
  - query parameter, query string 등으로 불리고, 여기에 입력된 값들은 모두 문자로 취급한다.
- fragment
  - html 내부 북마크 등에 사용하고, 서버에 전송하는 정보는 아니다.

## 웹 브라우저 요청 흐름

> `https://www.google.com`에 접속하는 과정에 대해 알아보자.

1. URL의 host를 이용해 DNS에서 IP주소를 찾는다.
2. HTTP 요청 메시지를 생성한다.
3. 애플리케이션, OS 계층 등을 거치며 HTTP 메시지를 패킷에 담는다.
4. 해당 패킷을 host(구글 서버)의 IP주소로 보낸다.
5. 서버에서 클라이언트로부터 전송된 HTTP 메시지(요청)를 읽는다.
6. 메시지에 대한 응답으로 HTTP 메시지(응답)을 생성하여 패킷에 담아 클라이언트에게 보낸다.
7. 서버로부터 받은 HTTP 메시지를 해석하여 클라이언트의 웹 브라우저를 렌더링한다.

## HTTP (HyperText Transfer Protocol)

- HTTP는 HTML과 같은 하이퍼미디어 문서를 전송하기 위한 애플리케이션 레이어 프로토콜이다.
  - HTML, Text, JSON, XML 등 거의 모든 형태의 데이터를 전송 가능하다.
- 웹 브라우저와 웹 서버 간의 커뮤니케이션을 위해 디자인되었지만, 서버간에 데이터를 주고 받을 때도 대부분 HTTP를 사용한다.

### HTTP의 역사

- HTTP/0.9 1991년 : GET 메서드만 지원, HTTP 헤더 X
- HTTP/1.0 1996년 : 메서드, 헤더 추가
- **HTTP/1.1 1997년 : 가장 많이 사용하고 가장 중요한 버전**
  - RFC2068(1997) -> RFC2616(1999) -> RFC 7230 ~ 7235 (2014)
- HTTP/2 2015년 : 성능 개선
- HTTP/3 진행중 : TCP 대신에 UDP 사용, 성능 개선

### 기반 프로토콜

- `TCP`: HTTP/1.1, HTTP/2
- `UDP` : HTTP/3
- 현재 HTTP/1.1을 주로 사용
  - HTTP/2, HTTP/2의 사용도 점점 증가

### HTTP의 특징

1. 클라이언트 - 서버 구조
2. 무상태(stateless) 프로토콜, 비연결성
3. HTTP 메시지
4. 단순함, 확장 가능

## 클라이언트 - 서버 구조

- Request Response 구조
- 클라이언트는 서버에 요청을 보내고, 응답을 대기한다.
- 서버는 클라이언트의 요청에 대한 결과를 만들어서 응답한다.
- 장점 : 각자의 역할에 집중할 수 있다.
  - 클라이언트에서는 복잡한 비즈니스 로직이나 데이터를 다룰 필요가 없고, UI를 그리는데 집중 할 수 있다.
  - 서버에서는 복잡한 비즈니스 로직이나 데이터를 다루는데만 집중하면 된다.
  - 만약 트래픽이 폭주하는 경우 클라이언트는 신경쓰지 않고, 서버만 생성하면 된다.

## 무상태 프로토콜

### 무상태(Stateless)

- 서버가 클라이언트의 상태를 보존하지 않는다.
- 장점 : 서버 확장성이 높다.(스케일 아웃)
- 단점 : 클라이언트가 추가 데이터를 전송해야 한다.

<p align="center">
  <img src ="https://user-images.githubusercontent.com/52318666/177280810-61ca7620-d2b3-4b00-aa84-6bdeaae934e2.png" >
</p>

<p align="center">
  <img src ="https://user-images.githubusercontent.com/52318666/177281032-87eb353a-9665-44ef-9bb1-d158d25165d5.png" >
</p>

<p align="center">
  <img src ="https://user-images.githubusercontent.com/52318666/177281126-b0b13732-d93c-4d26-b8c2-40c5eca6e5b9.png" >
</p>

<p align="center">
  <img src ="https://user-images.githubusercontent.com/52318666/177281346-66b75e2d-0ccf-49cc-b6b3-6b9e4139af19.png" >
</p>

- **실무에서의 한계**
  - 모든 것을 무상태로 설계할 수 있는 경우도 있고, 없는 경우도 있다.
  - 로그인이 필요없는 단순한 서비스 소개 화면은 -> 무상태로 설계
  - 로그인 -> 상태 유지로 설계
    - 로그인한 사용자의 경우 로그인을 했다는 상태를 서버에 유지해야 한다.
  - 일반적으로 브라우저의 쿠키와 서버 세션 등을 사용해서 상태를 유지한다.
  - 상태를 유지하지 않기 때문에 클라이언트가 많은 양의 정보를 전송해야 한다.
  - 상태 유지는 최소한만 사용해야 한다.

## 비 연결성(connectionless)

- 연결을 유지하는 모델
  - 클라이언트와 서버가 요청과 응답을 주고 받고 연결을 계속 유지한다.
  - 연결을 유지하는 동안 지속적으로 서버 자원을 소모한다.
- 연결을 유지하지 않는 모델
  - 클라이언트와 서버가 요청과 응답을 주고 받고 연결을 유지하지 않는다.
  - 서버 자원을 최소한으로 사용하기 때문에 자원의 낭비가 적다.
- HTTP는 기본적으로 연결을 유지하지 않는 모델이다.
- 일반적으로 초 단위의 이하의 빠른 속도로 응답한다.
- 1시간동안 수천명이 이용하는 서비스도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 작다.
  - ex) 웹 브라우저에서 모든 사용자가 같은 버튼을 연속해서 누르지는 않는다.
- 서버 자원을 매우 효율적으로 사용할 수 있다.
- 단점
  - TCP/IP 연결을 새로 맺어야 함 - 3 way handshake 시간 추가
  - 웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 자바스크립트, css, 추가 이미지 등 등 수 많은 자원을 함께 다운로드해야 된다. 
    이 때 연결을 유지하지 않는 모델은 HTML을 렌더링하다가 필요한 것이 생길 때마다 서버와 다시 연결을 맺어야 되는 경우가 발생한다.
  - 지금은 HTTP 지속 연결(Persistent Connections)로 문제 해결
  - HTTP/2, HTTP/3에서 더 많은 최적화

## HTTP 메시지

### HTTP 메시지 구조

```te
start-line(시작 라인)
header(헤더)
empty line(공백 라인)
message body(메시지 바디)
```

### 시작 라인 (요청 메시지)

- start-line = **request-line**

```te
GET /search?q=hello&hl=ko HTTP/1.1
...
```

- **request-line** = method SP(공백) request-target SP HTTP-version CRLF(엔터)
- method : HTTP 메서드 
  - 종류 : GET, POST, PUT, DELETE 등
  - 서버가 수행해야 할 동작을 지정
- request-target : 요청 대상
  - absolute-path[?query] (절대경로[?쿼리])
  - 절대경로= "/"로 시작하는 경로
- HTTP-version : HTTP/1.1, HTTP/2 등

### 시작 라인 (응답 메시지)

- start-line = **status-line**

```tex
HTTP/1.1 200 OK
...
```

- **status-line** = HTTP-version SP status-code SP reason-phrase CRLF
- HTTP-version
- status-code : 요청 성공, 실패를 나타낸다.
  - 200 ~ 299 : 성공 상태 코드
  - 400 ~ 499 : 클라이언트 에러 상태 코드
  - 500 ~ 599 : 서버 에러 상태 코드
- reason-phrase : 사람이 이해할 수 있는 짧은 상태 코드 설명 글

### HTTP 헤더

- header-field = field-name ":" OWS field-value OWS (OWS:띄어쓰기 허용)
  - field-name은 대소문자 구분이 없다.

```te
start-line
Host : www.google.com
...
```

- HTTP 전송에 필요한 모든 부가정보를 담고 있다.
  - ex) 메시지 바디의 내용, 메시지 바디의 크기, 압축, 인증, 요청 클라이언트(브라우저) 정보, 서버 애플리케이션 정보 등등
- 필요시 임의의 헤더 추가 가능

### HTTP 메시지 바디

- 실제 전송할 데이터
- HTML 문서, 이미지, 영상, JSON 등등 byte로 표현할 수 있는 모든 데이터의 전송이 가능하다.

## HTTP API를 만들어보자

- URL 설계시 가장 중요한 것은 `리소스 식별`이다.
- 여기서 리소스(Resource)의 의미는 무엇일까?
  - 회원의 정보를 관리하는 API를 설계한다고 했을 때, 회원의 등록, 수정, 조회, 삭제하는 것이 리소스가 아니다.
  - ex) 회원을 등록한다 -> 회원이 리소스이다.
  - **회원이라는 개념 그 자체가 리소스이다.**
- 그렇다면 리소스를 어떻게 식별하는게 좋을까?
  - 회원의 등록, 수정, 삭제, 조회하는 것을 모두 배제
  - **회원이라는 리소스만 식별하면 된다** -> **회원 리소스를 URI에 매핑한다.**

- 리소스 식별에 중심을 두고 URI를 설계하면 다음과 같을 것이다.
  - **회원** 목록 조회 /members
  - **회원** 등록 /members/{id} -> 어떻게 구분할까?
  - **회원** 수정 /members/{id} -> 어떻게 구분할까?
  - **회원** 삭제 /members/{id} -> 어떻게 구분할까?
  - **회원** 조회 /members/{id} -> 어떻게 구분할까?

- URI는 리소스만 식별하고, 리소스와 해당 리소스를 대상으로 하는 행위를 분리한다.
  - 리소스 : 회원
  - 행위 : 조회, 등록, 삭제, 수정
- 리소스는 명사, 행위는 동사 [ ex) 회원을 등록한다 ]

> 그럼 행위는 어떻게 구분해야 될까?

## HTTP 메서드 - GET, POST, PUT, PATCH, DELETE

### 주요 메서드 정리

- GET : 리소스 조회
- POST : 요청 데이터 처리, 주로 등록에 사용
- PUT : **리소스를 대체**, 해당 리소스가 없다면 생성
- PATCH : **리소스 부분 변경**
- DELETE : 리소스 삭제

### 기타 메서드 정리

- HEAD : GET과 동일하지만 메시지 부분은 제외하고, 상태 줄과 헤더만 반환
- OPTIONS : 대상 리소스에 대한 통신 가능 옵션(메서드)을 설명(주로 CORS)에서 사용
- CONNECT : 대상 자원으로 식별되는 서버에 대한 터널을 설정
- TRACE : 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행

### GET

- 리소스 조회
- 서버에 전달하고 싶은 데이터는 query(쿼리 파라미터, 쿼리 스트링)를 통해서 전달
- 메시지 바디를 사용해서 데이터를 전달할 수 있지만, 지원하지 않는 곳이 많아서 권장하지 않음

### POST

- 요청 데이터 처리
- 메시지 바디를 통해 서버로 요청 데이터를 전달
- 서버는 요청 데이터를 처리
  - 메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능을 수행
- 주로 전달받은 데이터를 이용해 신규 리소스의 등록, 프로세스 처리에 사용
  - example
    - HTML Form에 입력한 정보로 회원 가입, 주문 등
    - 게시판의 글쓰기, 댓글 달기
    - 신규 주문 생성
    - 문서의 끝에 내용 추가하기
- 리소스 URI에 POST 요청이 오면 요청 데이터를 어떻게 처리할지 리소스마다 따로 정해야 한다. -> 정해진 것이 없음

### PUT

- 리소스를 대체
  - 리소스가 있으면 완전히 대체
    - 기존의 존재하는 필드없이 수정한 필드만 PUT을 이용해 메시지를 보낸다면, 보내지 않은 필드는 삭제된다.
  - 리소스가 없으면 신규 생성
- **중요! 클라이언트가 리소스를 식별**
  - POST와는 다르게 클라이언트가 리소스의 위치를 알고 URI에 지정한다.

> PUT /members/100 HTTP/1.1
> Content-Type: application/json 
>
> {
>     "username": "hello",
>      "age": 20 
> }

### DELETE

- 리소스 제거

## HTTP 메서드의 속성

1. 안전(Safe Methods)
2. 멱등(Idempotent Methods)
3. 캐시 가능(Cacheable Methdos)

<p align="center">
  <img src ="https://user-images.githubusercontent.com/52318666/177695956-663bb212-562d-490c-900e-e0c2ad2e3276.png" >
</p>

### 안전

- 의미 : HTTP 메서드를 몇 번이나 호출해도 리소스를 변경시키지 않는다.

### 멱등

- 의미 : HTTP 메서드를 한 번 호출하든 두 번 호출하든 호출한 결과가 똑같다.
- 멱등 메서드
  - GET : 한 번 조회하나 두 번 조회하나 같은 결과가 조회된다.
  - PUT : 결과를 대체한다. 따라서 같은 요청을 여러 번 해도 최종 결과는 같다.
  - DELETE : 결과를 삭제한다. 같은 요청을 여러 번 해도 삭제된 결과는 같다.
  - **POST** : 두 번 호출하면 같은 결제가 중복해서 발생할 수 있다. 멱등 ❌
- 멱등의 활용
  - 멱등한 메서드는 자동 복구 메커니즘에 사용할 수 있다.
  - ex) 서버가 TIMEOUT의 이유로 정상 응답을 못주었을 때, 클라이언트가 같은 요청을 다시 보내도 되는가?의 판단 근거가 된다.

### 캐시 가능

- 의미 : 응답 결과 리소스를 캐시해서 사용해도 되는가?
- 캐시 가능 메서드 : GET, HEAD, POST, PATCH
- 실제로는 GET, HEAD 정도만 캐시로 사용
  - POST, PATCH는 본문 내용까지 캐시 키로 고려해야 하는데, 구현이 쉽지 않다.
- 캐시란?
  - 웹 캐시는 자주 쓰이는 문서의 사본을 자동으로 보관하는 HTTP 장치다.
  - 웹 요청이 캐시에 도착했을 때, 캐시된 로컬 사본이 존재한다면, 그 문서는 원 서버가 아니라 그 캐시로부터 제공된다.
  - 캐시의 장점
    1. 캐시는 불필요한 데이터 전송을 줄여서, 네트워크 요금으로 인한 비용을 줄여준다.
    2. 캐시는 네트워크 병목을 줄여준다. 대역폭을 늘리지 않고도 페이지를 빨리 불러 올 수 있게 된다.
    3. 캐시는 원 서버에 대한 요청을 줄여준다. 서버는 부하를 줄일 수 있으면 더 빨리 응답할 수 있게 된다.
    4. 페이지를 먼 곳에서 불러올수록 시간이 많이 걸리는데, 캐시는 거리로 인한 지연을 줄여준다.